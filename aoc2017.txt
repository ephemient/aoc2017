-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Advent of Code 2017 - my answers
--   
--   Please see the README on Github at
--   <a>https://github.com/ephemient/aoc2017#readme</a>
@package aoc2017
@version 0.1.0.0


module Day1

-- | The <a>digits</a> function returns a list of digits contained in a
--   string.
digits :: String -> [Int]
day1a :: String -> Int
day1b :: String -> Int


module Day2

-- | The <a>readSpreadsheet</a> function splits lines to rows and spaces to
--   columns.
readSpreadsheet :: String -> [[Int]]
day2a :: String -> Int
day2b :: String -> Int


module Day3
day3a :: Int -> Int
day3b :: Int -> Int


module Day4

-- | The <a>allUnique</a> function returns whether the list has no
--   duplicates.
allUnique :: (Eq a) => [a] -> Bool
day4a :: String -> Int
day4b :: String -> Int


module Day5

-- | At each step, the current item is used as a relative index shift.
steps :: (Int -> Int) -> [Int] -> Int
day5a :: String -> Int
day5b :: String -> Int


module Day6

-- | Reads the words of a string to an array.
parse :: (IArray a e, Ix i, Num i, Read e) => String -> a i e

-- | Returns the index and value of first maximum in an array.
top :: (IArray a e, Ix i, Ord e) => a i e -> (i, e)

-- | Removes the first maximum and redistributes its value throughout the
--   array.
redistribute :: (IArray a i, Integral i, Ix i) => a i i -> a i i

-- | The indices of the first two duplicated elements in a list.
indexDup :: (Ord a) => [a] -> Maybe (Int, Int)
day6a :: String -> Maybe Int
day6b :: String -> Maybe Int


module Day7

-- | Parses a string as a table of node name to node weight and children.
parseTree :: String -> Maybe [(String, (Int, [String]))]

-- | Finds a node with no parents.
findRoot :: (Ord a) => [(a, (b, [a]))] -> Maybe a

-- | Returns the most common element.
mode :: (Eq a) => [a] -> Maybe a

-- | Returns the total weight of the tree rooted at the given node.
--   
--   As a side effect, also <a>tell</a> the corrected weight for nodes
--   whose tree weight does not equal the majority of their siblings'.
weighTree :: (Monad m, MonadWriter [b] m, Ord a, Eq b, Num b) => Map a (b, [a]) -> a -> m b
day7a :: String -> Maybe String
day7b :: String -> Maybe Int


module Day8

-- | A conditional register instruction.
data Instruction reg val
Instruction :: reg -> (val -> val) -> (val -> Bool) -> reg -> Instruction reg val

-- | The register to be manipulated.
[target] :: Instruction reg val -> reg

-- | The operation to apply to <i>target</i>.
[op] :: Instruction reg val -> val -> val

-- | The condition on this instruction.
[cond] :: Instruction reg val -> val -> Bool

-- | The register for <i>cond</i> evaluation.
[when] :: Instruction reg val -> reg

-- | Parses a string into a sequence of instructions.
parse :: String -> [Instruction String Int]

-- | Returns an initial state with all known registered set to a constant
--   value.
initialize :: (Ord reg) => val -> [Instruction reg val] -> Map reg val

-- | Performs one operation on a register state, if the condition applies.
exec :: (Ord reg, Num val) => Map reg val -> Instruction reg val -> Map reg val
day8a :: String -> Int
day8b :: String -> Int
