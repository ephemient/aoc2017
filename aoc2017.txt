-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Advent of Code 2017 - my answers
--   
--   Please see the README on Github at
--   <a>https://github.com/ephemient/aoc2017#readme</a>
@package aoc2017
@version 0.1.0.0


module Day1

-- | The <a>digits</a> function returns a list of digits contained in a
--   string.
digits :: String -> [Int]
day1a :: String -> Int
day1b :: String -> Int


module Day10

-- | Reverse elements of an array in a range of indices. The range may
--   wrap.
reverseRange :: (IArray a e, Ix i, Num i) => a i e -> (i, i) -> a i e

-- | Given array bounds and a list of lengths, returns a list of ranges in
--   the array, with each one starting at an increasing distance from the
--   end of the previous, wrapping around the ends of the array.
knotRanges :: (Ix i, Num i) => (i, i) -> [Int] -> [(i, i)]

-- | Sequentially reverses all ranges in an array from a list of lengths.
hash :: (IArray a e, Ix i, Num i) => a i e -> [Int] -> a i e
day10a :: Int -> String -> Int
day10b :: String -> String


module Day11

-- | A single step on a hexagonal grid.
data Step
N :: Step
NE :: Step
SE :: Step
S :: Step
SW :: Step
NW :: Step

-- | A position on a hexagonal grid, in trapezoidal coordinates.
data Pos

-- | The distance along the N/S axis is given by <tt>x + y</tt>.
Pos :: !Int -> !Int -> Pos

-- | The distance along the NE/SW axis.
[x] :: Pos -> !Int

-- | The distance along the NW/SE axis.
[y] :: Pos -> !Int

-- | A representation of all hexagons touched along a path.
data Chart
Chart :: ((Int, Int), (Int, Int)) -> Int -> [((Int, Int), Int)] -> Chart

-- | Cartesian bounding box.
[bounds] :: Chart -> ((Int, Int), (Int, Int))

-- | The maximum distance from origin.
[maxDistance] :: Chart -> Int

-- | Hexagons and distances from origin.
[path] :: Chart -> [((Int, Int), Int)]

-- | Parse comma-separated steps.
parse :: String -> [Step]

-- | Move from a position by one step.
step :: Pos -> Step -> Pos

-- | Returns the minimum number of steps required to reach the origin.
walk :: Pos -> Int
day11a :: String -> Int
day11b :: String -> Int
chart :: String -> Chart
instance GHC.Read.Read Day11.Step


module Day12
parse :: String -> Map Int [Int]
connected :: (Ord a) => Map a [a] -> a -> Set a
day12a :: String -> Int
day12b :: String -> Int


module Day2

-- | The <a>readSpreadsheet</a> function splits lines to rows and spaces to
--   columns.
readSpreadsheet :: String -> [[Int]]
day2a :: String -> Int
day2b :: String -> Int


module Day3
day3a :: Int -> Int
day3b :: Int -> Int


module Day4

-- | The <a>allUnique</a> function returns whether the list has no
--   duplicates.
allUnique :: (Eq a) => [a] -> Bool
day4a :: String -> Int
day4b :: String -> Int


module Day5

-- | At each step, the current item is used as a relative index shift.
steps :: (Int -> Int) -> [Int] -> Int
day5a :: String -> Int
day5b :: String -> Int


module Day6

-- | Reads the words of a string to an array.
parse :: (IArray a e, Ix i, Num i, Read e) => String -> a i e

-- | Returns the index and value of first maximum in an array.
top :: (IArray a e, Ix i, Ord e) => a i e -> (i, e)

-- | Removes the first maximum and redistributes its value throughout the
--   array.
redistribute :: (IArray a i, Integral i, Ix i) => a i i -> a i i

-- | The indices of the first two duplicated elements in a list.
indexDup :: (Ord a) => [a] -> Maybe (Int, Int)
day6a :: String -> Maybe Int
day6b :: String -> Maybe Int


module Day7

-- | Parses a string as a table of node name to node weight and children.
parseTree :: String -> Maybe [(String, (Int, [String]))]

-- | Finds a node with no parents.
findRoot :: (Ord a) => [(a, (b, [a]))] -> Maybe a

-- | Returns the most common element.
mode :: (Eq a) => [a] -> Maybe a

-- | Returns the total weight of the tree rooted at the given node.
--   
--   As a side effect, also <a>tell</a> the corrected weight for nodes
--   whose tree weight does not equal the majority of their siblings'.
weighTree :: (Monad m, MonadWriter [b] m, Ord a, Eq b, Num b) => Map a (b, [a]) -> a -> m b
day7a :: String -> Maybe String
day7b :: String -> Maybe Int


module Day8

-- | Performs one operation on a register state, if the condition applies.
exec :: (Num a, Ord a, Read a) => Map String a -> String -> Map String a
day8a :: String -> Int
day8b :: String -> Int


module Day9
day9a :: String -> Int
day9b :: String -> Int
