-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Advent of Code 2017 - my answers
--   
--   Please see the README on Github at
--   <a>https://github.com/ephemient/aoc2017#readme</a>
@package aoc2017
@version 0.1.0.0


module Day1

-- | The <a>digits</a> function returns a list of digits contained in a
--   string.
digits :: String -> [Int]
day1a :: String -> Int
day1b :: String -> Int


module Day10

-- | Reverse elements of an array in a range of indices. The range may
--   wrap.
reverseRange :: (IArray a e, Ix i, Num i) => a i e -> (i, i) -> a i e

-- | Given array bounds and a list of lengths, returns a list of ranges in
--   the array, with each one starting at an increasing distance from the
--   end of the previous, wrapping around the ends of the array.
knotRanges :: (Ix i, Num i) => (i, i) -> [Int] -> [Maybe (i, i)]

-- | Sequentially reverses all ranges in an array from a list of lengths.
hash :: (IArray a e, Ix i, Num i) => a i e -> [Int] -> a i e

-- | Adds some magic numbers to the codepoints to a string, repeated 64
--   times.
deriveKey :: String -> [Int]

-- | Reduce consecutive groups of a fixed length by <tt>xor</tt>.
xorEach :: (IArray a e, Ix i, Bits e) => Int -> a i e -> [e]

-- | Deriving a key from a string by using its codepoints plus some magic
--   numbers, <a>hash</a> <tt>[0..255]</tt> 64 times, then <a>xor</a>
--   together each group of 16.
hashString :: String -> [Word8]
day10a :: Int -> String -> Int
day10b :: String -> String


module Day11

-- | A single step on a hexagonal grid.
data Step
N :: Step
NE :: Step
SE :: Step
S :: Step
SW :: Step
NW :: Step

-- | A position on a hexagonal grid, in trapezoidal coordinates.
data Pos

-- | The distance along the N/S axis is given by <tt>x + y</tt>.
Pos :: !Int -> !Int -> Pos

-- | The distance along the NE/SW axis.
[x] :: Pos -> !Int

-- | The distance along the NW/SE axis.
[y] :: Pos -> !Int

-- | A representation of all hexagons touched along a path.
data Chart
Chart :: ((Int, Int), (Int, Int)) -> Int -> [((Int, Int), Int)] -> Chart

-- | Cartesian bounding box.
[bounds] :: Chart -> ((Int, Int), (Int, Int))

-- | The maximum distance from origin.
[maxDistance] :: Chart -> Int

-- | Hexagons and distances from origin.
[path] :: Chart -> [((Int, Int), Int)]

-- | Parse comma-separated steps.
parse :: String -> [Step]

-- | Move from a position by one step.
step :: Pos -> Step -> Pos

-- | Returns the minimum number of steps required to reach the origin.
walk :: Pos -> Int
day11a :: String -> Int
day11b :: String -> Int
chart :: String -> Chart
instance GHC.Read.Read Day11.Step


module Day12

-- | Returns a mapping containing each input line "0 -&gt; 1, 2..".
parse :: String -> Map Int [Int]

-- | Returns the set of all nodes reachable from a seed node.
connected :: (Ord a) => Map a [a] -> a -> Set a
day12a :: String -> Int
day12b :: String -> Int


module Day13

-- | Maps each <tt>x: y</tt> line in the input to a <tt>(x, y)</tt> tuple.
parse :: String -> [(Int, Int)]

-- | <tt>combine (rs1, q1) (rs2, q2)</tt> returns an <tt>(rs3, lcm q1
--   q2)</tt> such that
--   
--   <pre>
--   and [r3 `mod` q1 `elem` rs1 &amp;&amp; r3 `mod` q2 `elem` rs2 | r3 &lt;- rs3]
--   </pre>
combine :: (Integral a) => ([a], a) -> ([a], a) -> ([a], a)
day13a :: String -> Int
day13b :: String -> Int


module Day14

-- | Given an input string, returns <a>hashString</a> of the string with a
--   dash and each integer in <tt>[0..127]</tt>.
grid :: String -> [[Word8]]

-- | Returns a list of bits from most-significant to least-significant.
bits :: (FiniteBits b) => b -> [Bool]

-- | Returns a list of the coordinates of connected groups of bits.
groupedBits :: (FiniteBits b) => [[b]] -> [[(Int, Int)]]
day14a :: String -> Int
day14b :: String -> Int


module Day15

-- | Returns the initial values for generators A and B.
parse :: String -> (Word32, Word32)
day15a :: String -> Int
day15b :: String -> Int


module Day16

-- | A dance move.
data Move i e
Spin :: i -> Move i e
Exchange :: i -> i -> Move i e
Partner :: e -> e -> Move i e

-- | Split words by whitespaces or commas.
words' :: String -> [String]

-- | Parse a list of dance moves.
parse :: String -> [Move Int Char]

-- | Compose two permutations.
(-*-) :: (IArray a e, IArray a' i, Ix i) => a i e -> a' i i -> a i e
infixl 7 -*-

-- | Repeat a permutation.
(-^-) :: (IArray a i, Ix i) => a i i -> Int -> a i i
infixr 8 -^-

-- | Like <a>id</a>, but swapping the two given values.
exchange :: (Eq a) => a -> a -> a -> a

-- | Given a list of dance moves, map out the resulting partner changes.
permuteNames :: (IArray a Char) => Int -> [Move i Char] -> a Char Char

-- | Given a list of dance moves, map out the resulting spins and
--   exchanges.
permuteIndices :: (IArray a Int) => Int -> [Move Int e] -> a Int Int
day16a :: Int -> String -> String
day16b :: Int -> Int -> String -> String


module Day17
day17a :: Int -> Int
day17b :: Int -> Int


module Day18

-- | A single instruction.
--   
--   <a>Either</a> represents either a register reference or an immediate
--   value.
data Ins reg val
Rcv :: reg -> Ins reg val
Snd :: (Either reg val) -> Ins reg val
Op :: (val -> val -> val) -> reg -> (Either reg val) -> Ins reg val
Jgz :: (Either reg val) -> (Either reg val) -> Ins reg val

-- | A specification for how to run a machine.
data MachineSpec m pc reg val
MachineSpec :: Array pc (Ins reg val) -> (val -> m ()) -> (val -> m val) -> MachineSpec m pc reg val

-- | The list of instructions.
[program] :: MachineSpec m pc reg val -> Array pc (Ins reg val)

-- | Handler for <a>Snd</a>.
[send] :: MachineSpec m pc reg val -> val -> m ()

-- | Handler for <a>Rcv</a>.
[recv] :: MachineSpec m pc reg val -> val -> m val

-- | The current state of a machine.
data MachineState pc reg val

-- | The machine is running.
MachineState :: pc -> Map reg val -> MachineState pc reg val

-- | The program counter.
[pc] :: MachineState pc reg val -> pc

-- | The registers.
[regs] :: MachineState pc reg val -> Map reg val

-- | The machine is stopped.
MachineTerminated :: MachineState pc reg val

-- | Parse an assembly listing to instructions.
parse :: (Integral a, Read a) => String -> [Ins String a]

-- | Evaluate a single instruction.
step :: (Monad m, Ix pc, Num pc, Ord reg, Integral val, Ord val) => MachineSpec m pc reg val -> MachineState pc reg val -> m (MachineState pc reg val)

-- | Run a machine until its state reaches <a>MachineTerminated</a>.
loop :: (Monad m, Ix pc, Num pc, Ord reg, Integral val, Ord val) => MachineSpec m pc reg val -> MachineState pc reg val -> m ()
day18a :: String -> Int64
day18b :: String -> Int


module Day19

-- | Represents a cardinal direction.
data Direction
U :: Direction
D :: Direction
L :: Direction
R :: Direction

-- | Returns the 2D representation of a string by lines and the index of
--   the only <tt>|</tt> pipe character on the first line.
parse :: (IArray a Char) => String -> (a (Int, Int) Char, (Int, Int))

-- | Rotates a cardinal direction by 180 degrees.
rot180 :: Direction -> Direction

-- | Moves a point one step in a cardinal direction.
move :: (Num a) => (a, a) -> Direction -> (a, a)

-- | Returns the cardinal directions around a point which contain
--   non-space.
joints :: (IArray a Char, Ix i, Num i) => a (i, i) Char -> (i, i) -> [Direction]

-- | Walks a maze from a starting point in a direction until it runs of
--   non-space characters to follow. Returns a list of all characters on
--   the walk.
walk :: (IArray a Char, Ix i, Num i) => a (i, i) Char -> (i, i) -> Direction -> String
day19a :: String -> String
day19b :: String -> Int
instance GHC.Classes.Eq Day19.Direction
instance GHC.Enum.Enum Day19.Direction
instance GHC.Enum.Bounded Day19.Direction


module Day2

-- | The <a>readSpreadsheet</a> function splits lines to rows and spaces to
--   columns.
readSpreadsheet :: String -> [[Int]]
day2a :: String -> Int
day2b :: String -> Int


module Day20

-- | A 3D vector.
data Vec3 a
Vec3 :: !a -> !a -> !a -> Vec3 a
[x] :: Vec3 a -> !a
[y] :: Vec3 a -> !a
[z] :: Vec3 a -> !a

-- | A point with position, velocity, and acceleration in 3D space.
data Point a
Point :: !(Vec3 a) -> !(Vec3 a) -> !(Vec3 a) -> Point a
[pos] :: Point a -> !(Vec3 a)
[vel] :: Point a -> !(Vec3 a)
[acc] :: Point a -> !(Vec3 a)

-- | Read non-overlapping substrings.
readMany :: (Read a) => String -> [a]

-- | Reads points.
parse :: (Read a) => String -> [Point a]

-- | Pointwise addition.
(*+*) :: (Num a) => Vec3 a -> Vec3 a -> Vec3 a
infixl 3 *+*

-- | Pointwise subtraction.
(*-*) :: (Num a) => Vec3 a -> Vec3 a -> Vec3 a
infixl 3 *-*

-- | Performs one timestep of velocity and position updates.
step :: (Num a) => Point a -> Point a

-- | Returns the Manhattan distance of a vector to the origin.
manhattan :: (Num a) => Vec3 a -> a

-- | Returns true if repeated <a>step</a> will not change the sign of any
--   component of velocity and position.
signumsMatch :: (Eq a, Num a) => Point a -> Bool

-- | Filters out all elements which are duplicated under transformation.
collide :: (Ord a) => (b -> a) -> [b] -> [b]
day20a :: String -> Int
day20b :: String -> [Int]
instance GHC.Classes.Ord a => GHC.Classes.Ord (Day20.Vec3 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Day20.Vec3 a)


module Day21

-- | Converts to a 2-D array with lower bound <tt>(0,0)</tt>.
array2D :: (IArray a e) => [[e]] -> a (Int, Int) e

-- | 8 affine transformations.
transforms :: (IArray a e, Ix i, Num i) => [a (i, i) e -> a (i, i) e]

-- | Parse a list of enhancements.
parse :: (IArray a Bool, Ord (a (Int, Int) Bool)) => String -> Map (a (Int, Int) Bool) (a (Int, Int) Bool)

-- | The glider.
start :: UArray (Int, Int) Bool

-- | Expand sub-squares according to the rules map.
step :: (IArray a e, Ord (a (Int, Int) e), MonadState (Map (a (Int, Int) e) (a (Int, Int) e)) m) => a (Int, Int) e -> m (a (Int, Int) e)

-- | <tt>day21 n input</tt> returns the number of bits set in the
--   <tt>n</tt>-th <a>step</a> of transforming the <a>start</a> glider
--   using <a>parse</a> rules from <tt>input</tt>.
day21 :: Int -> String -> Int
day21a :: String -> Int
day21b :: String -> Int


module Day22

-- | A cardinal direction.
data O
U :: O
R :: O
D :: O
L :: O

-- | Node state.
data S
C :: S
W :: S
I :: S
F :: S

-- | <a>succ</a> with wraparound.
next :: (Bounded a, Enum a, Eq a) => a -> a

-- | <a>pred</a> with wraparound.
prev :: (Bounded a, Enum a, Eq a) => a -> a

-- | Moves a Cartesian coordinate by one step in a direction.
move :: O -> Z -> Z

-- | Parses a string as a 2-D grid centered around <tt>(0, 0)</tt>,
--   returning positions with a <tt><tt>#</tt></tt> character.
parse :: String -> [Z]

-- | Returns all viral activity from an initial state.
day22 :: (Enum a, Eq a) => a -> (a -> O -> O) -> (a -> a) -> a -> Int -> [Z] -> Int
day22a :: String -> Int
day22b :: String -> Int
instance GHC.Classes.Eq Day22.S
instance GHC.Enum.Enum Day22.S
instance GHC.Enum.Bounded Day22.S
instance GHC.Classes.Eq Day22.O
instance GHC.Enum.Enum Day22.O
instance GHC.Enum.Bounded Day22.O


module Day23

-- | A single instruction.
--   
--   <a>Either</a> represents either a register reference or an immediate
--   value.
data Ins reg imm
Set :: reg -> Either reg imm -> Ins reg imm
[reg] :: Ins reg imm -> reg
[val] :: Ins reg imm -> Either reg imm
Sub :: reg -> Either reg imm -> Ins reg imm
[reg] :: Ins reg imm -> reg
[val] :: Ins reg imm -> Either reg imm
Mul :: reg -> Either reg imm -> Ins reg imm
[reg] :: Ins reg imm -> reg
[val] :: Ins reg imm -> Either reg imm
Jnz :: Either reg imm -> Either reg imm -> Ins reg imm
[cnd] :: Ins reg imm -> Either reg imm
[jmp] :: Ins reg imm -> Either reg imm

-- | The current state of a machine.
data State a reg imm
State :: Int -> a reg imm -> State a reg imm
[pc] :: State a reg imm -> Int
[regs] :: State a reg imm -> a reg imm

-- | Parses an immediate value or a single character register name.
parseVal :: (Read imm) => String -> Either Char imm

-- | Parses an assembly listing to instructions.
parse :: (Read imm) => String -> [Ins Char imm]

-- | Evaluates a single instruction.
step :: (IArray a imm, Ix reg, Integral imm) => [Ins reg imm] -> State a reg imm -> Maybe (State a reg imm)

-- | Evaluates the <tt>f = 0 if !isPrime(b)</tt> sequence, or a single
--   instruction.
stepOptimized :: (IArray a imm, Ix reg, Integral imm) => [Ins reg imm] -> State a reg imm -> Maybe (State a reg imm)

-- | Iterates a function until <a>Nothing</a>.
iterateMaybe :: (a -> Maybe a) -> Maybe a -> [a]
day23a :: String -> Int
day23b :: String -> Int


module Day3
day3a :: Int -> Int
day3b :: Int -> Int


module Day4

-- | The <a>allUnique</a> function returns whether the list has no
--   duplicates.
allUnique :: (Eq a) => [a] -> Bool
day4a :: String -> Int
day4b :: String -> Int


module Day5

-- | At each step, the current item is used as a relative index shift.
steps :: (Int -> Int) -> [Int] -> Int
day5a :: String -> Int
day5b :: String -> Int


module Day6

-- | Reads the words of a string to an array.
parse :: (IArray a e, Ix i, Num i, Read e) => String -> a i e

-- | Returns the index and value of first maximum in an array.
top :: (IArray a e, Ix i, Ord e) => a i e -> (i, e)

-- | Removes the first maximum and redistributes its value throughout the
--   array.
redistribute :: (IArray a i, Integral i, Ix i) => a i i -> a i i

-- | The indices of the first two duplicated elements in a list.
indexDup :: (Ord a) => [a] -> Maybe (Int, Int)
day6a :: String -> Maybe Int
day6b :: String -> Maybe Int


module Day7

-- | Parses a string as a table of node name to node weight and children.
parseTree :: String -> Maybe [(String, (Int, [String]))]

-- | Finds a node with no parents.
findRoot :: (Ord a) => [(a, (b, [a]))] -> Maybe a

-- | Returns the most common element.
mode :: (Eq a) => [a] -> Maybe a

-- | Returns the total weight of the tree rooted at the given node.
--   
--   As a side effect, also <a>tell</a> the corrected weight for nodes
--   whose tree weight does not equal the majority of their siblings'.
weighTree :: (Monad m, MonadWriter (First b) m, Ord a, Eq b, Num b) => Map a (b, [a]) -> a -> m b
day7a :: String -> Maybe String
day7b :: String -> Maybe Int


module Day8

-- | Performs one operation on a register state, if the condition applies.
exec :: (Num a, Ord a, Read a) => Map String a -> String -> Map String a
day8a :: String -> Int
day8b :: String -> Int


module Day9
day9a :: String -> Int
day9b :: String -> Int
